target_strategy
    logic_type (AND, OR)
    targets:
        component_type
        count
        condition_set
            logic_type (AND, OR)
            conditions
                condition_id (connects with component_type)

(assuming always unique among count)
counts
    1 - 10+
    all    
component_target_condition
    type: component_seat
        VALUES
        col_adjacent
        col_not_adjacent
        row_same
        row_adjacent
        row_not_adjacent
        row_lower
        row_higher
        row_back
        row_front
        col_same
        col_left
        col_leftmost
        col_right
        col_rightmost
        has_student
        no_student
        has_student_not_me
        has_student_me

    type: component_student
        actor
        not_actor
        id_me
        id_not_me
        less_grades
        more_grades
        less_popularity
        more_popularity
        adjacent
        not_adjacent



// EXAMPLE target_strategies

// myself & an adjacent student with more grades and less pop
{
    "logic_type": "AND",
    "component_type": "student",
    "component_property": null, // not a prop on component_type, but the obj itself
    "count": null, //ALL! should always be all for outer
    "target_sets": [
        {
            "logic_type": "AND",
            "component_type": "student", // same as outer type
            "component_property": null, // not a prop on component_type, but the obj itself
            "count": 1,
            "conditions": [
                "id_not_me", // with respect to actor's student
                "more_grades",
                "less_popularity",
                "adjacent"
            ],
            "condition_sets": []
        },
        {
            "logic_type": "AND",
            "component_type": "student", // same as outer type
            "component_property": null, // not a prop on component_type, but the obj itself
            "count": 1,
            "conditions": [
                "id_me"
            ]
        },
    ]

}
    
// all students in front of me with fewer grades
/*

    logic processing:
        (0) has a condition_set --> dive in
            (1) has no condition_sets, so it's a leaf node
            (1) component_type = seat so get caller's seat (seat_me)
            (1) get all seats (seats_all) (THIS IS BECAUSE I'm a LEAF!)
            (1) seats_all (col_same) --> where seat.col == seat_me.col
            (1) seats_all (row_lower) --> where seat.row < seat_me.row
            ---> yields seat_set
              -> convert seat_set -> student_set (via seat.student)
            ^ return to parent
        (0) aggregate student_set (concatenation of condition_sets results)
            condition_set_combination_type = AND so we join and dededupe on
            condition_set_dedupe_property
        (0) component_type = student so get caller's student (student_me)
        (0) student_set (id_not_me) --> where student.id != student_me.id
        (0) student_set (less_grades) --> where student.grades < student_me.grades
        ---> yields student_set (because component_property is null)
        ^ no parent, exit with student_set
*/
{
    "id": 0,
    "condition_set_combination_type": "AND",
    "condition_set_dedupe_property": null, // no need, no multiple children
    "component_type": "student",
    "component_property": null, // not a prop on component_type, but the obj itself
    "count": null, //ALL! 
    "conditions": [
        "id_not_me",
        "less_grades",
    ],
    "condition_sets": [
        {
            "id": 1,
            "logic_type": "AND",
            "component_type": "seat", // different so must have a way to get to parent type!
            "component_property": "student", // property type that will yield parent type
            "count": null, // ALL !
            "child_condition_set_dedupe_property": null, // no need, no children
            "conditions": [
                "col_same", // with respect to actor's seat
                "row_lower",
            ],
            "condition_sets": []
        }
    ]
}

// all students in the back row 

{
    "id": 2,
    "condition_set_combination_type": "AND",
    "result_set_dedupe_property": null, // no need, no children
    "component_type": "seat",
    "component_property": "student",
    "count": null,
    "conditions": [
        "row_back",
    ],
    "condition_sets": []
}

// now combine them for an OR

// (all students in the back row OR all students in front of me with fewer grades) with less_popularity

/*

    (4) has a condition_set --> dive in
        
        (0) has a condition_set --> dive in    
            (1) has no condition_sets, so it's a leaf node
            (1) component_type = seat so get caller's seat (seat_me)
            (1) get all seats (seats_all) (THIS IS BECAUSE I'm a LEAF!)
            (1) seats_all (col_same) --> where seat.col == seat_me.col
            (1) seats_all (row_lower) --> where seat.row < seat_me.row
            ---> yields seat_set
              -> convert seat_set -> student_set (via seat.student)
        <------- return to parent
        (0) aggregate student_set (concatenation of condition_sets results)
            condition_set_combination_type = AND 
            normally we join and dededupe on condition_set_dedupe_property
            but there are not multiple condition_sets so nvm
            so combined result set = [(result_0), (result_2)]
        (0) component_type = student so get caller's student (student_me)
        (0) student_set (id_not_me) --> where student.id != student_me.id
        (0) student_set (less_grades) --> where student.grades < student_me.grades
        ---> yields student_set (because component_property is null)
    <---- return result_0 to parent
    (4) STORE result_0
    (4) has another condition_set --> dive in  
        (2) has no condition_sets, so it's a leaf node
        (2) component_type = seat so get caller's seat (seat_me)
        (2) get all seats (seats_all) (THIS IS BECAUSE I'm a LEAF!)
        (2) seats_all (row_back) --> where seat.row == ROW_MAX
        ---> yields seat_set (because component_property is null)
    <------- return [result_2] to parent
    (4) STORE result_2, 
    (4) no more condition_set
    (4) condition_set_combination_type = "OR" so combined result set = [result_0, result_2]
    (4) component_type = student so get caller's student (student_me)
    (4) filter these seperately:
    --> (4) (result_0) student_set (less_popularity) --> where student.popularity < student_me.popularity
    ---> yields student_set (because component_property is null)
         AMEND result_0
    --> (4) (result_2) student_set (less_popularity) --> where student.popularity < student_me.popularity
    ---> yields student_set (because component_property is null) 
         AMEND result_2
<---- return [result_0, result_2] to parent
fi
*/

{
    "id": 4,
    "condition_set_combination_type": "OR",
    "result_set_dedupe_property": null, // no need, no children
    "component_type": "student",
    "returning_component_property": null,
    "count": null,
    "conditions": [
        "less_popularity"
    ],
    "condition_sets": [
        {
            "id": 0,
            "condition_set_combination_type": "AND",
            "condition_set_dedupe_property": null, // no need, no multiple children
            "component_type": "student",
            "returning_component_property": null, // not a prop on component_type, but the obj itself
            "count": null, //ALL! 
            "conditions": [
                "id_not_me",
                "less_grades",
            ],
            "condition_sets": [
                {
                    "id": 1,
                    "condition_set_combination_type": "AND",
                    "component_type": "seat", // different so must have a way to get to parent type!
                    "returning_component_property": "student", // property type that will yield parent type
                    "count": null, // ALL !
                    "child_condition_set_dedupe_property": null, // no need, no children
                    "conditions": [
                        "col_same", // with respect to actor's seat
                        "row_lower",
                    ],
                    "condition_sets": []
                }
            ]
        },
        {
            "id": 2,
            "condition_set_combination_type": "AND",
            "result_set_dedupe_property": null, // no need, no children
            "component_type": "seat",
            "returning_component_property": "student",
            "count": null,
            "conditions": [
                "row_back",
            ],
            "condition_sets": []
        }
    ]
}